# 微信小程序植物助手后端 - 统一认证拦截器开发方案

## 项目现状分析

### 当前问题
1. **认证方式不一致**：
   - `AuthController` 使用 `X-Token` + `TokenContext.validateToken()` 验证
   - 其他控制器（`PlantController`、`RecordController`、`ReminderController`）直接使用 `X-User-ID` 请求头，**存在安全漏洞**

2. **缺少统一拦截器**：每个接口方法手动验证Token，代码重复，维护困难

3. **Token存储限制**：内存存储（`TimedCache`），不适合分布式部署

4. **无权限控制**：只有基础认证，无角色/权限管理

### 当前认证流程
- 登录：`/api/auth/login` → 获取Token（有效期30天）
- 认证：`AuthController` 手动验证 `X-Token`，其他控制器使用 `X-User-ID`
- Token结构：包含 `openid`（微信openid）和 `userId`（用户表Long ID）
- 数据关联：业务表使用 `openid` 作为用户标识

### 当前数据模型问题
1. **字段命名不一致**：
   - 用户表：`users.openid` 存储微信openid
   - 业务表：`plants.user_id`、`records.user_id`、`reminders.user_id` 存储的是openid值
   - 代码中：实体类字段名为 `userId`，但实际存储的是openid
   - 语义混淆：`userId` 字段名表示用户ID，但实际存储的是openid

2. **命名规范不统一**：
   - 数据库列名：`user_id`（下划线命名）
   - Java字段名：`userId`（camelCase）
   - 实际值：微信openid字符串
   - 需要统一为：`openid` 字段名，明确表示存储的是微信openid

## 解决方案设计

### 核心目标
实现统一的Token认证拦截器，彻底解决当前安全问题，建立统一、可扩展的认证体系。

### 架构设计
```
com.tencent.wxcloudrun/
├── auth/                          # 新增认证模块
│   ├── LoginUser.java             # 登录用户信息类
│   └── LoginUserArgumentResolver.java  # 参数解析器
├── interceptor/
│   └── AuthInterceptor.java       # 统一认证拦截器
├── config/
│   └── WebConfig.java             # 配置拦截器和参数解析器
└── 改造现有4个控制器              # 方法参数改为LoginUser
```

### 技术选型
- **认证方式**：基于现有 `TokenContext` 的Token验证机制
- **拦截技术**：Spring MVC `HandlerInterceptor`
- **参数注入**：`HandlerMethodArgumentResolver` 自动注入 `LoginUser`
- **响应格式**：统一 `ApiResponse` 格式，HTTP 401状态码
- **工具库**：使用现有Hutool进行JSON序列化

## 详细设计

### 1. LoginUser类
```java
package com.tencent.wxcloudrun.auth;

import lombok.Data;
import java.io.Serializable;

/**
 * 当前登录用户信息
 * 轻量级设计，仅包含认证必需字段
 */
@Data
public class LoginUser implements Serializable {
    /** 微信openid（业务用户标识，原userId） */
    private String openid;
    
    /** 用户表主键ID（Long类型，仅用于关联用户表） */
    private Long userLongId;
    
    public LoginUser(String openid, Long userLongId) {
        this.openid = openid;
        this.userLongId = userLongId;
    }
    
    public LoginUser() {}
}
```

### 2. 认证常量类
```java
package com.tencent.wxcloudrun.auth;

public class AuthConstant {
    public static final String TOKEN_HEADER = "X-Token";
    public static final String LOGIN_USER_ATTR = "loginUser";
    public static final String OPENID_ATTR = "openid";
    public static final String USER_LONG_ID_ATTR = "userLongId";
    
    public static final String[] EXCLUDE_PATHS = {
        "/api/auth/login",
        "/error"
    };
}
```

### 3. 参数解析器（核心组件）

```java
package com.tencent.wxcloudrun.auth;

import com.tencent.wxcloudrun.constant.AuthConstant;
import org.springframework.core.MethodParameter;
import org.springframework.web.bind.support.WebDataBinderFactory;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.method.support.HandlerMethodArgumentResolver;
import org.springframework.web.method.support.ModelAndViewContainer;

import javax.servlet.http.HttpServletRequest;

/**
 * LoginUser参数解析器
 * 自动将Token验证后的用户信息注入到Controller方法参数
 */
@Component
public class LoginUserArgumentResolver implements HandlerMethodArgumentResolver {

   @Override
   public boolean supportsParameter(MethodParameter parameter) {
      return parameter.getParameterType().equals(LoginUser.class);
   }

   @Override
   public Object resolveArgument(MethodParameter parameter,
                                 ModelAndViewContainer mavContainer,
                                 NativeWebRequest webRequest,
                                 WebDataBinderFactory binderFactory) {

      HttpServletRequest request = (HttpServletRequest) webRequest.getNativeRequest();

      // 从拦截器设置的属性中获取用户信息
      String openid = (String) request.getAttribute(AuthConstant.OPENID_ATTR);
      Long userLongId = (Long) request.getAttribute(AuthConstant.USER_LONG_ID_ATTR);

      if (openid == null || userLongId == null) {
         // 拦截器已验证Token，这里应该不会为null
         return null;
      }

      return new LoginUser(openid, userLongId);
   }
}
```

### 4. 统一认证拦截器

```java
package com.tencent.wxcloudrun.interceptor;

import com.tencent.wxcloudrun.constant.AuthConstant;
import com.tencent.wxcloudrun.constant.CodeEnum;
import com.tencent.wxcloudrun.context.TokenContext;
import com.tencent.wxcloudrun.dto.resp.ApiResponse;
import cn.hutool.json.JSONUtil;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
public class AuthInterceptor implements HandlerInterceptor {

   @Resource
   private TokenContext tokenContext;

   @Override
   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
      String uri = request.getRequestURI();

      // 排除登录接口
      for (String excludePath : AuthConstant.EXCLUDE_PATHS) {
         if (uri.contains(excludePath)) {
            return true;
         }
      }

      // OPTIONS预检请求
      if ("OPTIONS".equalsIgnoreCase(request.getMethod())) {
         return true;
      }

      // 获取并验证Token
      String token = request.getHeader(AuthConstant.TOKEN_HEADER);
      if (!StringUtils.hasText(token)) {
         writeUnauthorizedResponse(response, "缺少认证Token");
         return false;
      }

      TokenContext.TokenInfo tokenInfo = tokenContext.validateToken(token);
      if (tokenInfo == null || tokenInfo.isExpired()) {
         writeUnauthorizedResponse(response, "Token无效或已过期");
         return false;
      }

      // 存储用户信息到请求属性（供参数解析器使用）
      request.setAttribute(AuthConstant.OPENID_ATTR, tokenInfo.getOpenid());
      request.setAttribute(AuthConstant.USER_LONG_ID_ATTR, tokenInfo.getUserId());

      return true;
   }

   private void writeUnauthorizedResponse(HttpServletResponse response, String message) throws IOException {
      response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
      response.setContentType("application/json;charset=UTF-8");
      ApiResponse<?> apiResponse = ApiResponse.of(CodeEnum.UNAUTHORIZED.getCode(), message, null);
      response.getWriter().write(JSONUtil.toJsonStr(apiResponse));
   }
}
```

### 5. Web配置（注册拦截器和参数解析器）
```java
package com.tencent.wxcloudrun.config;

import com.tencent.wxcloudrun.auth.LoginUserArgumentResolver;
import com.tencent.wxcloudrun.interceptor.AuthInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.method.support.HandlerMethodArgumentResolver;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import javax.annotation.Resource;
import java.util.List;

@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Resource
    private AuthInterceptor authInterceptor;
    
    @Resource
    private LoginUserArgumentResolver loginUserArgumentResolver;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(authInterceptor)
                .addPathPatterns("/api/**")
                .excludePathPatterns(AuthConstant.EXCLUDE_PATHS);
    }
    
    @Override
    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {
        resolvers.add(loginUserArgumentResolver);
    }
}
```

## 改造示例

### AuthController改造
```java
// 修改前：
@PostMapping("/updateProfile")
public ApiResponse<ProfileResponse> updateProfile(
        @RequestHeader("X-Token") String token,
        @Valid @RequestBody ProfileRequest request) {
    TokenContext.TokenInfo tokenInfo = tokenContext.validateToken(token);
    if (tokenInfo == null) {
        return ApiResponse.error("登录已过期，请重新登录");
    }
    return ApiResponse.ok(authService.updateProfile(tokenInfo.getOpenid(), request));
}

// 修改后：
@PostMapping("/updateProfile")
public ApiResponse<ProfileResponse> updateProfile(
        @Valid @RequestBody ProfileRequest request,
        LoginUser loginUser) {  // 直接使用LoginUser参数
    return ApiResponse.ok(authService.updateProfile(loginUser.getOpenid(), request));
}
```

### PlantController改造
```java
// 修改前：
@PostMapping("/createPlant")
public ApiResponse<Plant> createPlant(@RequestBody PlantRequest request,
                                   @RequestHeader("X-User-ID") String userId) {
    request.setUserId(userId);
    Plant plant = plantService.createPlant(request);
    return ApiResponse.ok(plant);
}

// 修改后：
@PostMapping("/createPlant")
public ApiResponse<Plant> createPlant(@RequestBody PlantRequest request,
                                   LoginUser loginUser) {
    request.setUserId(loginUser.getOpenid());  // openid作为业务userId
    Plant plant = plantService.createPlant(request);
    return ApiResponse.ok(plant);
}
```

### 不需要用户信息的接口（保持原样）
```java
@PostMapping("/login")
public ApiResponse<LoginResponse> login(@Valid @RequestBody LoginRequest request) {
    // 不需要LoginUser参数
    LoginResponse loginResponse = authService.login(request);
    return ApiResponse.ok(loginResponse);
}
```

## 实施步骤

### 第一阶段：创建基础组件（45分钟）
1. 创建 `com.tencent.wxcloudrun.auth.LoginUser` 类
2. 创建 `com.tencent.wxcloudrun.constant.AuthConstant` 常量类
3. 创建 `com.tencent.wxcloudrun.auth.LoginUserArgumentResolver` 参数解析器

### 第二阶段：改造拦截器（30分钟）
1. 创建 `com.tencent.wxcloudrun.interceptor.AuthInterceptor` 拦截器

### 第三阶段：配置注册（15分钟）
1. 创建/修改 `com.tencent.wxcloudrun.config.WebConfig` 类
2. 注册拦截器和参数解析器

### 第四阶段：改造Controller（2小时）
按以下顺序改造：
1. `AuthController.java` - 3个方法
2. `PlantController.java` - 5个方法  
3. `RecordController.java` - 5个方法
4. `ReminderController.java` - 6个方法

**改造模式**：
- 移除 `@RequestHeader("X-Token")` 和 `@RequestHeader("X-User-ID")`
- 添加 `LoginUser loginUser` 参数（需要用户信息的方法）
- 使用 `loginUser.getOpenid()` 获取用户标识

### 第五阶段：测试验证（1小时）
0. **测试前询问是否开始测试**
1. **单元测试**：参数解析器逻辑
2. **集成测试**：
   - 登录接口正常工作
   - 认证接口需要Token
   - LoginUser参数自动注入
   - 用户数据正确隔离
3. **回归测试**：所有现有功能

## 代码改造清单

### 新增文件（4个）
1. `src/main/java/com/tencent/wxcloudrun/auth/LoginUser.java`
2. `src/main/java/com/tencent/wxcloudrun/auth/AuthConstant.java`
3. `src/main/java/com/tencent/wxcloudrun/auth/LoginUserArgumentResolver.java`
4. `src/main/java/com/tencent/wxcloudrun/interceptor/AuthInterceptor.java`

### 修改文件（5个）
1. `src/main/java/com/tencent/wxcloudrun/config/WebConfig.java` - 新增或修改
2. `src/main/java/com/tencent/wxcloudrun/controller/AuthController.java` - 3个方法
3. `src/main/java/com/tencent/wxcloudrun/controller/PlantController.java` - 5个方法
4. `src/main/java/com/tencent/wxcloudrun/controller/RecordController.java` - 5个方法
5. `src/main/java/com/tencent/wxcloudrun/controller/ReminderController.java` - 6个方法

### 方法签名变更
**移除参数**：
- `@RequestHeader("X-Token") String token`
- `@RequestHeader("X-User-ID") String userId`

**新增参数**：
- `LoginUser loginUser`（需要用户信息的方法）

## 风险与应对措施

| 风险 | 影响等级 | 应对措施 |
|------|----------|----------|
| 接口兼容性破坏 | 高 | 一次性全面改造，确保所有接口同步更新 |
| Token验证逻辑变更 | 中 | 保持与原有 `TokenContext.validateToken()` 相同逻辑 |
| 用户信息传递方式变更 | 中 | 使用LoginUser替代请求头，确保数据类型一致 |
| 拦截器路径配置错误 | 中 | 仔细配置包含/排除路径，测试验证 |
| Service层参数依赖 | 低 | Service层接口不变，仅控制器调用方式调整 |

## 预期收益

1. **安全性提升**：统一Token验证，消除 `X-User-ID` 直接传递的安全漏洞
2. **代码可维护性**：消除重复验证代码，认证逻辑集中管理
3. **类型安全**：LoginUser强类型，避免字符串操作错误
4. **框架集成**：深度集成Spring MVC参数解析机制
5. **代码简洁**：Controller方法参数清晰，业务逻辑专注
6. **可扩展性**：为后续改造（如Redis存储）奠定基础
7. **开发效率**：新接口无需关注认证细节，专注业务逻辑
8. **标准化**：统一错误响应格式（401状态码 + ApiResponse）

## 注意事项

1. **Service层兼容性**：Service方法继续接收String类型的userId（openid），保持不变
2. **数据库关联**：业务表使用openid作为用户标识，需要确保一致性
3. **性能考虑**：参数解析器只创建轻量级LoginUser对象，不查询数据库
4. **用户标识统一**：所有业务逻辑使用openid作为用户标识

## 验证清单

- [ ] 拦截器正确验证有效Token
- [ ] 拦截器正确拒绝无效/过期Token
- [ ] 登录接口 (`/api/auth/login`) 不受拦截
- [ ] 所有业务接口需要Token认证
- [ ] LoginUser参数自动注入到Controller方法
- [ ] 用户数据正确隔离（用户A无法访问用户B数据）
- [ ] 错误响应格式统一（401状态码 + ApiResponse）
- [ ] 现有所有功能测试通过
- [ ] 性能无显著下降

## 后续优化方向（可选）

### 短期优化（1-2周）
1. **统一CORS配置**：在 `WebConfig` 中集中配置跨域
2. **API访问日志**：添加请求日志拦截器
3. **Token自动续期**：活跃用户Token自动延长有效期

### 中期优化（1-2月）
1. **Redis Token存储**：替换内存存储，支持分布式部署
2. **第三方登录集成**：微信、QQ、手机号等多种登录方式

### 长期优化
1. **多端登录支持**：Web端、App端不同Token策略
2. **安全审计日志**：记录所有认证相关操作

---

**方案设计完成时间**：2025年2月5日  
**预计实施时间**：4小时（开发3小时 + 测试1小时）  
**方案状态**：待实施